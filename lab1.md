# ЛР №1. Основы функционального программирования на JS

## Задание

### Вариант 1: Обработка списка студентов

Дан массив объектов, представляющих студентов:

```js
const students = [
  { name: "Alice", grade: 85, major: "Math" },
  { name: "Bob", grade: 92, major: "Science" },
  { name: "Charlie", grade: 78, major: "Math" },
  { name: "David", grade: 95, major: "Science" },
  { name: "Eve", grade: 88, major: "Math" }
];
```

Необходимо:

1. Создать функцию `filterByMajor(students, major)`, которая фильтрует массив `students` и возвращает новый массив только со студентами, обучающимися по заданной специальности `major`.
2. Создать функцию `getAverageGrade(students)`, которая вычисляет средний балл студентов в заданном массиве.
3. Создать функцию `getTopStudents(students, n)`, которая возвращает массив из `n` лучших студентов (с самым высоким баллом) в заданном массиве.
4. Используя созданные функции, получить массив студентов, обучающихся на математическом факультете ("Math"), вычислить их средний балл и выбрать двух лучших студентов.

### Вариант 2: Трансформация и агрегация данных о продуктах

Дан массив объектов, представляющих продукты:

```js
const products = [
  { name: "Apple", price: 1.0, category: "Fruit" },
  { name: "Banana", price: 0.5, category: "Fruit" },
  { name: "Carrot", price: 0.75, category: "Vegetable" },
  { name: "Broccoli", price: 1.5, category: "Vegetable" },
  { name: "Orange", price: 0.8, category: "Fruit" }
];
```

Необходимо:

1. Создать функцию `groupByCategory(products)`, которая группирует продукты по категориям и возвращает объект, где ключи – это названия категорий, а значения – массивы продуктов, относящихся к этой категории.
2. Создать функцию `applyDiscount(products, discount)`, которая применяет заданную скидку `discount` (в процентах) ко всем продуктам в массиве и возвращает новый массив с обновленными ценами.
3. Создать функцию `calculateTotalValue(products)`, которая вычисляет общую стоимость всех продуктов в массиве.
4. Используя созданные функции, сгруппировать продукты по категориям, применить скидку 10% ко всем продуктам и вычислить общую стоимость продуктов в категории "Fruit".

### Вариант 3: Работа с текстовыми данными

Дан массив строк:

```js
const sentences = [
  "This is a sentence.",
  "Another sentence here.",
  "A short one.",
  "A very long sentence with many words."
];
```

Необходимо:

1. Создать функцию `wordCount(sentence)`, которая подсчитывает количество слов в заданной строке.
2. Создать функцию `longestSentence(sentences)`, которая находит самую длинную строку (по количеству слов) в заданном массиве и возвращает ее.
3. Создать функцию `filterSentencesByLength(sentences, minLength)`, которая фильтрует массив `sentences` и возвращает новый массив только со строками, содержащими не менее `minLength` слов.
4. Используя созданные функции, найти самую длинную строку в массиве sentences и отфильтровать массив, оставив только строки, содержащие не менее 5 слов.

### Вариант 4: Композиция функций и каррирование

Необходимо:

1. Создать функцию `add(x, y)`, которая складывает два числа.
2. Создать функцию `multiply(x, y)`, которая умножает два числа.
3. Создать функцию `square(x)`, которая возводит число в квадрат.
4. Используя каррирование и композицию функций, создать функцию `squareAndAdd(x, y, z)`, которая выполняет следующую операцию: (x² + y) * z. Каррирование должно быть реализовано таким образом, чтобы функцию можно было вызывать последовательно: `squareAndAdd(x)(y)(z)`.

### Вариант 5: Обработка заказов

Дан массив объектов, представляющих заказы:

```js
const orders = [
  { orderId: 1, customerId: 101, items: [{ productId: 1, quantity: 2, price: 10 }, { productId: 2, quantity: 1, price: 20 }] },
  { orderId: 2, customerId: 102, items: [{ productId: 3, quantity: 3, price: 5 }, { productId: 4, quantity: 2, price: 15 }] },
  { orderId: 3, customerId: 101, items: [{ productId: 1, quantity: 1, price: 10 }] }
];
```

Необходимо:

1. Создать функцию `calculateOrderTotal(order)`, которая вычисляет общую стоимость одного заказа.
2. Создать функцию `getOrdersByCustomerId(orders, customerId)`, которая фильтрует массив `orders` и возвращает новый массив только с заказами для заданного `customerId`.
3. Создать функцию `getCustomerOrderTotal(orders, customerId)`, которая вычисляет общую сумму всех заказов для заданного `customerId`.
4. Используя созданные функции, вычислить общую сумму заказов для клиента с `customerId = 101`.

### Вариант 6: Работа с массивом чисел

Дан массив чисел:

```js
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
```

Необходимо:

1. Создать функцию `isEven(number)`, которая проверяет, является ли число четным.
2. Создать функцию `square(number)`, которая возводит число в квадрат.
3. Создать функцию `sumArray(numbers)`, которая вычисляет сумму элементов массива.
4. Используя созданные функции и функции высшего порядка, получить массив четных чисел, возвести каждое из них в квадрат и вычислить сумму квадратов.

### Вариант 7: Валидация данных

Дан массив строк, представляющих email-адреса:

```js
const emails = [
  "test@example.com",
  "invalid-email",
  "another@valid.com",
  "not.a.valid.email@",
  "good@domain.net"
];
```

Необходимо:

1. Создать функцию `isValidEmail(email)`, которая проверяет, является ли строка валидным email-адресом (использовать регулярное выражение).
2. Создать функцию `filterValidEmails(emails)`, которая фильтрует массив `emails` и возвращает новый массив только с валидными email-адресами.
3. Создать функцию `transformEmailsToLowerCase(emails)`, которая преобразует все email-адреса в нижний регистр.
4. Используя созданные функции, отфильтровать массив `emails`, оставив только валидные email-адреса, и преобразовать их в нижний регистр.

### Вариант 8: Реализация `Map`, `Filter` и `Reduce` своими руками

Необходимо:

1. Создать функцию `myMap(array, callback)`, которая реализует функциональность метода `map` для массивов.
2. Создать функцию `myFilter(array, callback)`, которая реализует функциональность метода `filter` для массивов.
3. Создать функцию `myReduce(array, callback, initialValue)`, которая реализует функциональность метода `reduce` для массивов.
4. Проверить работу созданных функций.

### Вариант 9: Трансформация данных о книгах

Дан массив объектов, представляющих книги:

```js
const books = [
  { title: "The Lord of the Rings", author: "J.R.R. Tolkien", year: 1954 },
  { title: "Pride and Prejudice", author: "Jane Austen", year: 1813 },
  { title: "1984", author: "George Orwell", year: 1949 },
  { title: "To Kill a Mockingbird", author: "Harper Lee", year: 1960 }
];
```

Необходимо:

1. Создать функцию `getBookTitles(books)`, которая возвращает массив только с названиями книг.
2. Создать функцию `getBooksPublishedBefore(books, year)`, которая фильтрует массив `books` и возвращает новый массив только с книгами, опубликованными до заданного года.
3. Создать функцию `getBookAuthors(books)`, которая возвращает массив только с авторами книг, при этом каждый автор должен быть уникальным (без повторений).

### Вариант 10: Работа с деревом (рекурсия)

Дан объект, представляющий дерево:

```js
const tree = {
  value: 1,
  children: [
    { value: 2, children: [{ value: 4, children: [] }, { value: 5, children: [] }] },
    { value: 3, children: [{ value: 6, children: [] }] }
  ]
};
```

Необходимо:

1. Создать рекурсивную функцию `treeSum(tree)`, которая вычисляет сумму всех значений в дереве.
2. Создать рекурсивную функцию `treeMap(tree, callback)`, которая применяет функцию `callback` к каждому значению в дереве и возвращает новое дерево с обновленными значениями.
3. Создать рекурсивную функцию `treeFilter(tree, callback)`, которая фильтрует дерево, удаляя узлы, для которых `callback` возвращает `false`.