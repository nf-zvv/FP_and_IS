# Основы функционального программирования на Racket

Функциональным называется программирование при помощи функций в математическом их понимании. Функциональное программирование основано на следующей идее: в результате каждого действия возникает значение, которое может быть аргументом следующего действия. Программы строятся из логически расчлененных определений функций.

Каждое определение функции состоит из организующих вычисления управляющих структур и из вложенных, в том числе вызывающих самих себя (рекурсивных), вызовов функций. При выполнении программы функции получают параметры, вычисляют и возвращают результат, при необходимости вычисляя значения других функций.

## Язык программирования Racket

Racket - это современный функциональный язык программирования, относящийся к семейству Lisp. Он разработан для обучения, исследований и разработки программного обеспечения, поддерживая чисто функциональный стиль, а также императивные и объектно-ориентированные подходы. Особенностью Racket является мощная система макросов и инструментов, благодаря которым язык широко используется для создания собственных языков программирования. Это делает Racket гибким инструментом как для новичков, так и для опытных разработчиков.

Ссылки:

- [Официальный сайт Racket](https://racket-lang.org/)
- [Среда разработки DrRacket](https://download.racket-lang.org/)
- [Документация Racket](https://docs.racket-lang.org/)
- [Online компилятор Racket](https://onecompiler.com/racket)

### Основы синтаксиса Racket

Racket принадлежит к семейству языков программирования Lisp, поэтому код записывается в виде списков, заключённых в круглые скобки. Отступы и переносы строк не имеют синтаксического значения, но рекомендуются для читаемости. 

Каждое выражение начинается с имени функции или оператора, за которым следуют аргументы, например:

```lisp
(функция аргумент1 аргумент2 ...)
```

Пример, сложение 2 и 3 выполняется следующим образом:

```lisp
(+ 2 3)
```

#### Определение функций

Для создания функции используется конструкция `define`. В теле функции может быть одно или несколько выражений; результатом функции является значение последнего выражения.

```lisp
(define (имя-функции параметры)
    тело-функции)
```

Пример функции, вычисляющей квадрат числа:

```lisp
(define (square x)
(* x x))
```

Вызов функции:

```lisp
(square 5) ; результат 25

```

#### Рекурсия

В функциональном программировании широко используется рекурсия - функция вызывает сама себя для решения задачи. Важно всегда обеспечивать базовый случай, иначе рекурсия будет бесконечной. Например, вычисление факториала:

```lisp
(define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1)))))
```

#### Условные выражения

Для ветвления используется `if`. Условие должно возвращать логическое значение `#t` (true) или `#f` (false).

```lisp
(if условие
    выражение_если_истина
    выражение_если_ложь)
```

Для более сложных ветвлений используется `cond`:

```lisp
(cond
    [(условие1) выражение1]
    [(условие2) выражение2]
    [else выражение_по_умолчанию])
```

#### Работа со списками

Список - основная структура данных. Создаётся с помощью `'()` или `(list ...)`. Напрмиер:

```lisp
  (define my-list '(1 2 3 4))

```

Основные функции для работы со списками:

- `cons` - добавляет элемент в начало списка.
- `car` - возвращает первый элемент списка.
- `cdr` - возвращает список без первого элемента.
- `null?` - проверяет, пуст ли список.

Пример обхода списка:

```lisp
(define (sum-list lst)
    (if (null? lst)
        0
        (+ (car lst) (sum-list (cdr lst)))))
```

#### Функции высшего порядка

Функции могут принимать другие функции в качестве аргументов и возвращать функции. Часто используются `map`, `filter`, `foldr` для работы со списками.

`map` применяет функцию ко всем элементам списка и возвращает новый список. Пример применения `map`:

```lisp
(map (lambda (x) (* x x)) '(1 2 3 4)) ; Результат: (1 4 9 16)
```

`filter` выбирает элементы, удовлетворяющие предикату:

```lisp
(filter even? '(1 2 3 4)) ; (2 4)
```

`foldr` и `foldl` сворачивают список в одно значение, применяя функцию:

```lisp
(foldr + 0 '(1 2 3 4)) ; 10
```

#### Лямбда-выражения

Анонимные функции создаются с помощью `lambda`:

```lisp
(lambda (параметры) тело)
```

Часто используются вместе с функциями высшего порядка. См. выше пример с использованием `lambda` и `map`.

#### Имутабельность

В функциональном программировании данные считаются неизменяемыми. Вместо изменения существующих структур создаются новые. Это упрощает понимание кода и обеспечивает отсутствие побочных эффектов.

#### Основные типы данных

- Числа (целые, вещественные, рациональные)
- Логические значения: `#t` (истина), `#f` (ложь)
- Символы и строки
- Списки и пары
- Векторы, хэш-таблицы и другие структуры данных

### Простые задачи для изучения синтаксиса и основных приемов работы на Racket

#### Задание 1. Приветствие

Напишите функцию `greet`, которая принимает имя (строку) и возвращает строку приветствия, например:

```lisp
(greet "Маша") → "Привет, Маша!"
```

Цель: познакомиться с определением функций и строками.

#### Задание 2. Сложение чисел

Напишите функцию `add-two`, которая принимает два числа и возвращает их сумму.

```lisp
(add-two 3 5) → 8 
```

Цель: научиться работать с числами и аргументами функции.

#### Задание 3. Проверка чётности

Напишите функцию `is-even?`, которая принимает число и возвращает `#t`, если число чётное, и `#f` — если нечётное.

```lisp
(is-even? 4) → #t 
(is-even? 7) → #f 
```

Цель: познакомиться с условными выражениями и логикой.

#### Задание 4. Максимум из двух чисел

Напишите функцию `max-two`, которая принимает два числа и возвращает большее из них.

```lisp
(max-two 10 7) → 10
```

Цель: использовать условные конструкции `if` или `cond`.

#### Задание 5. Рекурсивное суммирование

Напишите рекурсивную функцию `sum-to-n`, которая принимает число `n` и возвращает сумму всех чисел от 1 до `n`.

```lisp
(sum-to-n 5) → 15 (1+2+3+4+5)
```

Цель: понять рекурсию.

#### Задание 6. Обработка списков — длина списка

Напишите функцию `list-length`, которая принимает список и возвращает его длину.

```lisp
(list-length '(1 2 3 4)) → 4
```

Цель: работать со списками и рекурсией.

#### Задание 7. Обработка списков — сумма элементов

Напишите функцию `sum-list`, которая принимает список чисел и возвращает их сумму.

```lisp
(sum-list '(1 2 3 4)) → 10
```

Цель: практиковаться с рекурсией и списками.

#### Задание 8. Фильтрация списка

Напишите функцию `filter-even`, которая принимает список чисел и возвращает новый список, содержащий только чётные числа.

```lisp
(filter-even '(1 2 3 4 5 6)) → (2 4 6)
```

Цель: познакомиться с фильтрацией и функциями высшего порядка (можно использовать `filter`).

#### Задание 9. Применение функции к списку

Напишите функцию `double-list`, которая принимает список чисел и возвращает список их удвоенных элементов.

```lisp
(double-list '(1 2 3 4)) → (2 4 6 8)
```

Цель: использовать функцию высшего порядка `map`.

### Продвинутое задание

Написать решение задания из [ЛР№1](lab1.md) в функциональном стиле на языке Racket.
